# 개발 브랜치 정리
### 1.  최초 막 개발한 환경
* master 브랜치

### 2.  1번을 리펙토링한 환경
* was-step1.1-live-coding 브랜치

# 리펙토링 사항

### 1. 요청 객체 리펙토링
* 기존에 내가 짠 코드보다 더 좋다.
* 왜냐면 
    1.  클라이언트의 주요 관심사만 노출하고 그렇지 않은 부분은 숨긴다.
    2.  요청 정보 클래스를 분리하였다.
    3.  응답 정보 클래스를 분리하였다.
    4.  요청 path 별 분기문으로 처리하던 로직을 다형성을 활용해 통일했고 RequestMapping 클래스를 만들어서 요청 path에 대한 적절한 클래스를 찾을 수 있도록 했다.
          * 이로 인해, controller가 추가될 때 기존 코드 수정 없이 컨트롤러 하나 만들고 RequestMapping에 등록만 해 주면 됨!
          * ![image](https://user-images.githubusercontent.com/41561652/146323163-da354f25-4af4-452d-b7c3-a4f8b0bb707c.png)



### 2.  기억하고 싶은 문구
* 객체에서 값을 꺼내 로직을 구현하려 하지 말고 객체에게 메시지를 보내 일을 시키도록 연습하자.
  * 즉, 객체에 해당 일을 할 수 있는 메소드를 구현하고 클라이언트는 메소드를 호출하여 객체에게 일을 시키는 구조를 추구하자
* 이렇게 객체를 최대한 활용하는 과정에서 복잡도가 증가하고 사이즈가 커질 때 책임을 분리해야 함을 느끼자
* 클래스를 분리하면 테스트도 편해진다.

### 3.  서블릿과 서블릿 컨테이너
1. 서블릿
    * 해당 프로젝트에서 구현한 Controller, HttpRequest, HttpResponse 부분을 표준화 한 인터페이스
    * 즉,  HTTP 클라이언트의 요청과 응답에 대한 표준
2.  서블릿 컨테이너
    * 서블릿 인터페이스를 구현하고 호출하는 것을 담당
3.  서블릿과 서블릿 컨테이너의 관계ㄴ
    * 내가 구현한 코드를 보면 서버가 시작하는 시점 컨트롤러를 생성 후, RequestMapping에 요청 URL과 생성한 컨트롤러를 메핑해 둔다. 
    * 그리고 실제 요청이 오면 미리 생성해둔 메핑 정보를 활용해 컨트롤러를 찾고 해당 컨트롤러에게 작업을 위임한다.
    * 서블릿과 서블릿 컨테이너의 관계도 정확히 동일하다.